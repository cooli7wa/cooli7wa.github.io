I"+K<p>在区块链的世界里，一方面由于是分布式存储，一样的数据存储在所有的节点里，如果数据中包含无用的字节，那么在所有节点中浪费的总量就很客观，另一方面虽然数字货币的交易速率都不高，但是至少也有每秒几笔（比特币）到几十笔（以太坊），如果每笔交易中都包含一定的无用字节，那么时间长了，就会浪费掉非常大的空间。</p>

<p>所以在比特币和以太坊中都有一些为了减少浪费而做的设计。</p>

<h3 id="比特币-varint">比特币 VarInt</h3>

<p>VarInt (VI) 在比特币的 transaction 里面使用很多，用来表示后面跟的数据的字节数。在之前的 <a href="http://cooli7wa.com//2018/08/20/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BA%A4%E6%98%93%E4%BD%93/">比特币-交易体</a> 有过一些介绍，为了方便阅读这里再重复下，看下面这张图：</p>

<p><img src="/images/md/transaction_3.png" alt="" /></p>

<p>这是 transation TxIn 的一部分，里面的 VI 就是 VarInt，VI 的长度根据后面所跟数据的长度来变化，具体的定义：</p>

<p><img src="/images/md/transaction_2.png" alt="" /></p>

<p>如果数据长度小于 0xFD，那么就只有一个字节长度，本身就代表长度。</p>

<p>如果数据长度大于0xFD，那么第一个字节就是一个标示符，代表的是后面跟着的字节是什么类型的 Int，比如 uint16、uint32、uint64，这个 int 是数据的长度。</p>

<p>这种设计方式，目前已经为比特币节省了 10 多 G的存储空间。</p>

<h3 id="以太坊-rlprecursive-length-prefix">以太坊 RLP（Recursive Length Prefix）</h3>

<p>以太坊没有比特币那样复杂的交易体，只是一个简单的结构体，RLP 是用来解决结构体的编码问题。<strong>注意必须是大端字节序</strong>。</p>

<p>在 RLP 内也需要表示数据长度，所以也有类似 VarInt 的设计，先总体说下，然后看下代码。</p>

<h4 id="1-概述">1. 概述</h4>

<p>RLP 只针对两种数据结构，字符串和列表，对于字典数据，以太坊有两种建议的方式，一种是通过二维数组表达键值对，比如<code class="language-plaintext highlighter-rouge">[[k1,v1],[k2,v2]...]</code>，并且对键进行字典序排序；另一种方式是通过以太坊文档中提到的高级的<a href="https://github.com/ethereum/wiki/wiki/Patricia-Tree">基数树</a> 编码来实现。</p>

<p>具体编码规则和例子如下：</p>

<p><img src="/images/md/RLP_VarInt_0.png" alt="" /></p>

<p><strong>字符串长度为 1 的情况比较特殊，列表的编码实际是个递归的过程，下面会说</strong></p>

<h4 id="2-代码">2. 代码</h4>

<p>这段代码来自 web3j，编码过程。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RlpEncoder</span> <span class="o">{</span>

  	<span class="c1">// 判断编码类别，字符串还是列表</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encode</span><span class="o">(</span><span class="nc">RlpType</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="k">instanceof</span> <span class="nc">RlpString</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">encodeString</span><span class="o">((</span><span class="nc">RlpString</span><span class="o">)</span> <span class="n">value</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">encodeList</span><span class="o">((</span><span class="nc">RlpList</span><span class="o">)</span> <span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

  	<span class="c1">// 编码流程，字符串和列表都是通过这个函数编码，只不过列表有一个迭代的过程</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encode</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">bytesValue</span><span class="o">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="o">)</span> <span class="o">{</span>
      	<span class="c1">// 对应于字符串编码，且长度为 1 的情况</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">bytesValue</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="o">&amp;&amp;</span> <span class="n">offset</span> <span class="o">==</span> <span class="no">OFFSET_SHORT_STRING</span> <span class="c1">// OFFSET_SHORT_STRING = 0x80</span>
                <span class="o">&amp;&amp;</span> <span class="n">bytesValue</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mh">0x00</span>
                <span class="o">&amp;&amp;</span> <span class="n">bytesValue</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mh">0x7f</span><span class="o">)</span> <span class="o">{</span>
          	<span class="c1">// 直接返回字符串原文</span>
            <span class="k">return</span> <span class="n">bytesValue</span><span class="o">;</span>
        <span class="c1">// 长度小于 55 的情况</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">bytesValue</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">55</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">bytesValue</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
            <span class="c1">// offset，字符串是0x80，列表是0xc0</span>
            <span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="o">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">bytesValue</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">bytesValue</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">result</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">bytesValue</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          	<span class="c1">// 得到长度的长度的字节数组</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">encodedStringLength</span> <span class="o">=</span> <span class="n">toMinimalByteArray</span><span class="o">(</span><span class="n">bytesValue</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">bytesValue</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">encodedStringLength</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
			<span class="c1">// offset，字符串是 0x80，列表是 0xc0，加上 0x37 之后，分别为 0xb7 和 0xf7</span>
            <span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="o">((</span><span class="n">offset</span> <span class="o">+</span> <span class="mh">0x37</span><span class="o">)</span> <span class="o">+</span> <span class="n">encodedStringLength</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">encodedStringLength</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">result</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">encodedStringLength</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span>
                    <span class="n">bytesValue</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">result</span><span class="o">,</span> <span class="n">encodedStringLength</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">bytesValue</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encodeString</span><span class="o">(</span><span class="nc">RlpString</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">encode</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(),</span> <span class="no">OFFSET_SHORT_STRING</span><span class="o">);</span>
    <span class="o">}</span>

  	<span class="c1">// 根据长度的长度计算字节流，按照大端的顺序写入到字节数组里，选择非 0 的最小段</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">toMinimalByteArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">encoded</span> <span class="o">=</span> <span class="n">toByteArray</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">encoded</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">encoded</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">encoded</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">encoded</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[]{</span> <span class="o">};</span>
    <span class="o">}</span>

  	<span class="c1">// 根据数值计算出字节流，按照大端顺序写入数组</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">toByteArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[]</span> <span class="o">{</span>
                <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="o">((</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="o">),</span>
                <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="o">((</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="o">),</span>
                <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="o">((</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="o">),</span>
                <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="o">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="o">)</span>
        <span class="o">};</span>
    <span class="o">}</span>

  	<span class="c1">// 将列表迭代编码</span>
    <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encodeList</span><span class="o">(</span><span class="nc">RlpList</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">RlpType</span><span class="o">&gt;</span> <span class="n">values</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">getValues</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">values</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">encode</span><span class="o">(</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[]{</span> <span class="o">},</span> <span class="no">OFFSET_SHORT_LIST</span><span class="o">);</span> <span class="c1">// OFFSET_SHORT_LIST = 0xc0</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">RlpType</span> <span class="nl">entry:</span><span class="n">values</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">concat</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">encode</span><span class="o">(</span><span class="n">entry</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="nf">encode</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="no">OFFSET_SHORT_LIST</span><span class="o">);</span> <span class="c1">// OFFSET_SHORT_LIST = 0xc0</span>
        <span class="o">}</span>
    <span class="o">}</span>

  	<span class="c1">// 链接数组</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">concat</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">b1</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">b2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">b1</span><span class="o">,</span> <span class="n">b1</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">b2</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">b2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">result</span><span class="o">,</span> <span class="n">b1</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">b2</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

:ET